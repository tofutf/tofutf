// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

var _ genericConn = (*pgx.Conn)(nil)
var _ RegisterConn = (*pgx.Conn)(nil)

const insertWorkspaceSQL = `INSERT INTO workspaces (
    workspace_id,
    created_at,
    updated_at,
    agent_pool_id,
    allow_cli_apply,
    allow_destroy_plan,
    auto_apply,
    branch,
    can_queue_destroy_plan,
    description,
    environment,
    execution_mode,
    global_remote_state,
    migration_environment,
    name,
    queue_all_runs,
    speculative_enabled,
    source_name,
    source_url,
    structured_run_output_enabled,
    terraform_version,
    trigger_prefixes,
    trigger_patterns,
    vcs_tags_regex,
    working_directory,
    organization_name
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    $18,
    $19,
    $20,
    $21,
    $22,
    $23,
    $24,
    $25,
    $26
);`

type InsertWorkspaceParams struct {
	ID                         pgtype.Text        `json:"id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AgentPoolID                pgtype.Text        `json:"agent_pool_id"`
	AllowCLIApply              pgtype.Bool        `json:"allow_cli_apply"`
	AllowDestroyPlan           pgtype.Bool        `json:"allow_destroy_plan"`
	AutoApply                  pgtype.Bool        `json:"auto_apply"`
	Branch                     pgtype.Text        `json:"branch"`
	CanQueueDestroyPlan        pgtype.Bool        `json:"can_queue_destroy_plan"`
	Description                pgtype.Text        `json:"description"`
	Environment                pgtype.Text        `json:"environment"`
	ExecutionMode              pgtype.Text        `json:"execution_mode"`
	GlobalRemoteState          pgtype.Bool        `json:"global_remote_state"`
	MigrationEnvironment       pgtype.Text        `json:"migration_environment"`
	Name                       pgtype.Text        `json:"name"`
	QueueAllRuns               pgtype.Bool        `json:"queue_all_runs"`
	SpeculativeEnabled         pgtype.Bool        `json:"speculative_enabled"`
	SourceName                 pgtype.Text        `json:"source_name"`
	SourceURL                  pgtype.Text        `json:"source_url"`
	StructuredRunOutputEnabled pgtype.Bool        `json:"structured_run_output_enabled"`
	TerraformVersion           pgtype.Text        `json:"terraform_version"`
	TriggerPrefixes            []string           `json:"trigger_prefixes"`
	TriggerPatterns            []string           `json:"trigger_patterns"`
	VCSTagsRegex               pgtype.Text        `json:"vcs_tags_regex"`
	WorkingDirectory           pgtype.Text        `json:"working_directory"`
	OrganizationName           pgtype.Text        `json:"organization_name"`
}

// InsertWorkspace implements Querier.InsertWorkspace.
func (q *DBQuerier) InsertWorkspace(ctx context.Context, params InsertWorkspaceParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertWorkspace")
	cmdTag, err := q.conn.Exec(ctx, insertWorkspaceSQL, params.ID, params.CreatedAt, params.UpdatedAt, params.AgentPoolID, params.AllowCLIApply, params.AllowDestroyPlan, params.AutoApply, params.Branch, params.CanQueueDestroyPlan, params.Description, params.Environment, params.ExecutionMode, params.GlobalRemoteState, params.MigrationEnvironment, params.Name, params.QueueAllRuns, params.SpeculativeEnabled, params.SourceName, params.SourceURL, params.StructuredRunOutputEnabled, params.TerraformVersion, params.TriggerPrefixes, params.TriggerPatterns, params.VCSTagsRegex, params.WorkingDirectory, params.OrganizationName)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query InsertWorkspace: %w", err)
	}
	return cmdTag, err
}

const findWorkspacesSQL = `SELECT
    w.*,
    (
        SELECT array_agg(name)
        FROM tags
        JOIN workspace_tags wt USING (tag_id)
        WHERE wt.workspace_id = w.workspace_id
    ) AS tags,
    r.status AS latest_run_status,
    (
        SELECT (u.*)::"users"
        FROM users u
        WHERE u.username = w.lock_username
    ) AS user_lock,
    (
        SELECT (rl.*)::"runs"
        FROM runs rl
        WHERE rl.run_id = w.lock_run_id
    ) AS run_lock,
    (
        SELECT (rc.*)::"repo_connections"
        FROM repo_connections rc
        WHERE rc.workspace_id = w.workspace_id
    ) AS workspace_connection
FROM workspaces w
LEFT JOIN runs r ON w.latest_run_id = r.run_id
LEFT JOIN (workspace_tags wt JOIN tags t USING (tag_id)) ON wt.workspace_id = w.workspace_id
WHERE w.name                LIKE '%' || $1 || '%'
AND   w.organization_name   LIKE ANY($2)
GROUP BY w.workspace_id, r.status
HAVING array_agg(t.name) @> $3
ORDER BY w.updated_at DESC
LIMIT $4
OFFSET $5
;`

type FindWorkspacesParams struct {
	Search            pgtype.Text `json:"search"`
	OrganizationNames []string    `json:"organization_names"`
	Tags              []string    `json:"tags"`
	Limit             pgtype.Int8 `json:"limit"`
	Offset            pgtype.Int8 `json:"offset"`
}

type FindWorkspacesRow struct {
	WorkspaceID                pgtype.Text        `json:"workspace_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AllowDestroyPlan           pgtype.Bool        `json:"allow_destroy_plan"`
	AutoApply                  pgtype.Bool        `json:"auto_apply"`
	CanQueueDestroyPlan        pgtype.Bool        `json:"can_queue_destroy_plan"`
	Description                pgtype.Text        `json:"description"`
	Environment                pgtype.Text        `json:"environment"`
	ExecutionMode              pgtype.Text        `json:"execution_mode"`
	GlobalRemoteState          pgtype.Bool        `json:"global_remote_state"`
	MigrationEnvironment       pgtype.Text        `json:"migration_environment"`
	Name                       pgtype.Text        `json:"name"`
	QueueAllRuns               pgtype.Bool        `json:"queue_all_runs"`
	SpeculativeEnabled         pgtype.Bool        `json:"speculative_enabled"`
	SourceName                 pgtype.Text        `json:"source_name"`
	SourceURL                  pgtype.Text        `json:"source_url"`
	StructuredRunOutputEnabled pgtype.Bool        `json:"structured_run_output_enabled"`
	TerraformVersion           pgtype.Text        `json:"terraform_version"`
	TriggerPrefixes            []string           `json:"trigger_prefixes"`
	WorkingDirectory           pgtype.Text        `json:"working_directory"`
	LockRunID                  pgtype.Text        `json:"lock_run_id"`
	LatestRunID                pgtype.Text        `json:"latest_run_id"`
	OrganizationName           pgtype.Text        `json:"organization_name"`
	Branch                     pgtype.Text        `json:"branch"`
	LockUsername               pgtype.Text        `json:"lock_username"`
	CurrentStateVersionID      pgtype.Text        `json:"current_state_version_id"`
	TriggerPatterns            []string           `json:"trigger_patterns"`
	VCSTagsRegex               pgtype.Text        `json:"vcs_tags_regex"`
	AllowCLIApply              pgtype.Bool        `json:"allow_cli_apply"`
	AgentPoolID                pgtype.Text        `json:"agent_pool_id"`
	Tags                       []string           `json:"tags"`
	LatestRunStatus            pgtype.Text        `json:"latest_run_status"`
	UserLock                   *Users             `json:"user_lock"`
	RunLock                    *Runs              `json:"run_lock"`
	WorkspaceConnection        *RepoConnections   `json:"workspace_connection"`
}

// FindWorkspaces implements Querier.FindWorkspaces.
func (q *DBQuerier) FindWorkspaces(ctx context.Context, params FindWorkspacesParams) ([]FindWorkspacesRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaces")
	rows, err := q.conn.Query(ctx, findWorkspacesSQL, params.Search, params.OrganizationNames, params.Tags, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspaces: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindWorkspacesRow, error) {
		var item FindWorkspacesRow
		if err := row.Scan(&item.WorkspaceID, // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt,                  // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.UpdatedAt,                  // 'updated_at', 'UpdatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.AllowDestroyPlan,           // 'allow_destroy_plan', 'AllowDestroyPlan', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AutoApply,                  // 'auto_apply', 'AutoApply', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.CanQueueDestroyPlan,        // 'can_queue_destroy_plan', 'CanQueueDestroyPlan', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.Description,                // 'description', 'Description', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Environment,                // 'environment', 'Environment', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.ExecutionMode,              // 'execution_mode', 'ExecutionMode', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.GlobalRemoteState,          // 'global_remote_state', 'GlobalRemoteState', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.MigrationEnvironment,       // 'migration_environment', 'MigrationEnvironment', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,                       // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.QueueAllRuns,               // 'queue_all_runs', 'QueueAllRuns', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.SpeculativeEnabled,         // 'speculative_enabled', 'SpeculativeEnabled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.SourceName,                 // 'source_name', 'SourceName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.SourceURL,                  // 'source_url', 'SourceURL', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.StructuredRunOutputEnabled, // 'structured_run_output_enabled', 'StructuredRunOutputEnabled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.TerraformVersion,           // 'terraform_version', 'TerraformVersion', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.TriggerPrefixes,            // 'trigger_prefixes', 'TriggerPrefixes', '[]string', '', '[]string'
			&item.WorkingDirectory,           // 'working_directory', 'WorkingDirectory', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LockRunID,                  // 'lock_run_id', 'LockRunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LatestRunID,                // 'latest_run_id', 'LatestRunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName,           // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Branch,                     // 'branch', 'Branch', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LockUsername,               // 'lock_username', 'LockUsername', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CurrentStateVersionID,      // 'current_state_version_id', 'CurrentStateVersionID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.TriggerPatterns,            // 'trigger_patterns', 'TriggerPatterns', '[]string', '', '[]string'
			&item.VCSTagsRegex,               // 'vcs_tags_regex', 'VCSTagsRegex', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AllowCLIApply,              // 'allow_cli_apply', 'AllowCLIApply', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AgentPoolID,                // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Tags,                       // 'tags', 'Tags', '[]string', '', '[]string'
			&item.LatestRunStatus,            // 'latest_run_status', 'LatestRunStatus', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.UserLock,                   // 'user_lock', 'UserLock', '*Users', '', '*Users'
			&item.RunLock,                    // 'run_lock', 'RunLock', '*Runs', '', '*Runs'
			&item.WorkspaceConnection,        // 'workspace_connection', 'WorkspaceConnection', '*RepoConnections', '', '*RepoConnections'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const countWorkspacesSQL = `WITH
    workspaces AS (
        SELECT w.workspace_id
        FROM workspaces w
        LEFT JOIN (workspace_tags wt JOIN tags t USING (tag_id)) ON w.workspace_id = wt.workspace_id
        WHERE w.name              LIKE '%' || $1 || '%'
        AND   w.organization_name LIKE ANY($2)
        GROUP BY w.workspace_id
        HAVING array_agg(t.name) @> $3
    )
SELECT count(*)
FROM workspaces
;`

type CountWorkspacesParams struct {
	Search            pgtype.Text `json:"search"`
	OrganizationNames []string    `json:"organization_names"`
	Tags              []string    `json:"tags"`
}

// CountWorkspaces implements Querier.CountWorkspaces.
func (q *DBQuerier) CountWorkspaces(ctx context.Context, params CountWorkspacesParams) (pgtype.Int8, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CountWorkspaces")
	rows, err := q.conn.Query(ctx, countWorkspacesSQL, params.Search, params.OrganizationNames, params.Tags)
	if err != nil {
		return pgtype.Int8{}, fmt.Errorf("query CountWorkspaces: %w", err)
	}

	return pgx.CollectOneRow(rows, func(row pgx.CollectableRow) (pgtype.Int8, error) {
		var item pgtype.Int8
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findWorkspacesByConnectionSQL = `SELECT
    w.*,
    (
        SELECT array_agg(name)
        FROM tags
        JOIN workspace_tags wt USING (tag_id)
        WHERE wt.workspace_id = w.workspace_id
    ) AS tags,
    r.status AS latest_run_status,
    (ul.*)::"users" AS user_lock,
    (rl.*)::"runs" AS run_lock,
    (rc.*)::"repo_connections" AS workspace_connection
FROM workspaces w
LEFT JOIN users ul ON w.lock_username = ul.username
LEFT JOIN runs rl ON w.lock_run_id = rl.run_id
LEFT JOIN runs r ON w.latest_run_id = r.run_id
JOIN repo_connections rc ON w.workspace_id = rc.workspace_id
WHERE rc.vcs_provider_id = $1
AND   rc.repo_path = $2
;`

type FindWorkspacesByConnectionRow struct {
	WorkspaceID                pgtype.Text        `json:"workspace_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AllowDestroyPlan           pgtype.Bool        `json:"allow_destroy_plan"`
	AutoApply                  pgtype.Bool        `json:"auto_apply"`
	CanQueueDestroyPlan        pgtype.Bool        `json:"can_queue_destroy_plan"`
	Description                pgtype.Text        `json:"description"`
	Environment                pgtype.Text        `json:"environment"`
	ExecutionMode              pgtype.Text        `json:"execution_mode"`
	GlobalRemoteState          pgtype.Bool        `json:"global_remote_state"`
	MigrationEnvironment       pgtype.Text        `json:"migration_environment"`
	Name                       pgtype.Text        `json:"name"`
	QueueAllRuns               pgtype.Bool        `json:"queue_all_runs"`
	SpeculativeEnabled         pgtype.Bool        `json:"speculative_enabled"`
	SourceName                 pgtype.Text        `json:"source_name"`
	SourceURL                  pgtype.Text        `json:"source_url"`
	StructuredRunOutputEnabled pgtype.Bool        `json:"structured_run_output_enabled"`
	TerraformVersion           pgtype.Text        `json:"terraform_version"`
	TriggerPrefixes            []string           `json:"trigger_prefixes"`
	WorkingDirectory           pgtype.Text        `json:"working_directory"`
	LockRunID                  pgtype.Text        `json:"lock_run_id"`
	LatestRunID                pgtype.Text        `json:"latest_run_id"`
	OrganizationName           pgtype.Text        `json:"organization_name"`
	Branch                     pgtype.Text        `json:"branch"`
	LockUsername               pgtype.Text        `json:"lock_username"`
	CurrentStateVersionID      pgtype.Text        `json:"current_state_version_id"`
	TriggerPatterns            []string           `json:"trigger_patterns"`
	VCSTagsRegex               pgtype.Text        `json:"vcs_tags_regex"`
	AllowCLIApply              pgtype.Bool        `json:"allow_cli_apply"`
	AgentPoolID                pgtype.Text        `json:"agent_pool_id"`
	Tags                       []string           `json:"tags"`
	LatestRunStatus            pgtype.Text        `json:"latest_run_status"`
	UserLock                   *Users             `json:"user_lock"`
	RunLock                    *Runs              `json:"run_lock"`
	WorkspaceConnection        *RepoConnections   `json:"workspace_connection"`
}

// FindWorkspacesByConnection implements Querier.FindWorkspacesByConnection.
func (q *DBQuerier) FindWorkspacesByConnection(ctx context.Context, vcsProviderID pgtype.Text, repoPath pgtype.Text) ([]FindWorkspacesByConnectionRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspacesByConnection")
	rows, err := q.conn.Query(ctx, findWorkspacesByConnectionSQL, vcsProviderID, repoPath)
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspacesByConnection: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindWorkspacesByConnectionRow, error) {
		var item FindWorkspacesByConnectionRow
		if err := row.Scan(&item.WorkspaceID, // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt,                  // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.UpdatedAt,                  // 'updated_at', 'UpdatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.AllowDestroyPlan,           // 'allow_destroy_plan', 'AllowDestroyPlan', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AutoApply,                  // 'auto_apply', 'AutoApply', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.CanQueueDestroyPlan,        // 'can_queue_destroy_plan', 'CanQueueDestroyPlan', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.Description,                // 'description', 'Description', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Environment,                // 'environment', 'Environment', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.ExecutionMode,              // 'execution_mode', 'ExecutionMode', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.GlobalRemoteState,          // 'global_remote_state', 'GlobalRemoteState', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.MigrationEnvironment,       // 'migration_environment', 'MigrationEnvironment', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,                       // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.QueueAllRuns,               // 'queue_all_runs', 'QueueAllRuns', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.SpeculativeEnabled,         // 'speculative_enabled', 'SpeculativeEnabled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.SourceName,                 // 'source_name', 'SourceName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.SourceURL,                  // 'source_url', 'SourceURL', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.StructuredRunOutputEnabled, // 'structured_run_output_enabled', 'StructuredRunOutputEnabled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.TerraformVersion,           // 'terraform_version', 'TerraformVersion', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.TriggerPrefixes,            // 'trigger_prefixes', 'TriggerPrefixes', '[]string', '', '[]string'
			&item.WorkingDirectory,           // 'working_directory', 'WorkingDirectory', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LockRunID,                  // 'lock_run_id', 'LockRunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LatestRunID,                // 'latest_run_id', 'LatestRunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName,           // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Branch,                     // 'branch', 'Branch', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LockUsername,               // 'lock_username', 'LockUsername', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CurrentStateVersionID,      // 'current_state_version_id', 'CurrentStateVersionID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.TriggerPatterns,            // 'trigger_patterns', 'TriggerPatterns', '[]string', '', '[]string'
			&item.VCSTagsRegex,               // 'vcs_tags_regex', 'VCSTagsRegex', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AllowCLIApply,              // 'allow_cli_apply', 'AllowCLIApply', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AgentPoolID,                // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Tags,                       // 'tags', 'Tags', '[]string', '', '[]string'
			&item.LatestRunStatus,            // 'latest_run_status', 'LatestRunStatus', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.UserLock,                   // 'user_lock', 'UserLock', '*Users', '', '*Users'
			&item.RunLock,                    // 'run_lock', 'RunLock', '*Runs', '', '*Runs'
			&item.WorkspaceConnection,        // 'workspace_connection', 'WorkspaceConnection', '*RepoConnections', '', '*RepoConnections'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findWorkspacesByUsernameSQL = `SELECT
    w.*,
    (
        SELECT array_agg(name)
        FROM tags
        JOIN workspace_tags wt USING (tag_id)
        WHERE wt.workspace_id = w.workspace_id
    ) AS tags,
    r.status AS latest_run_status,
    (ul.*)::"users" AS user_lock,
    (rl.*)::"runs" AS run_lock,
    (rc.*)::"repo_connections" AS workspace_connection
FROM workspaces w
JOIN workspace_permissions p USING (workspace_id)
LEFT JOIN users ul ON w.lock_username = ul.username
LEFT JOIN runs rl ON w.lock_run_id = rl.run_id
LEFT JOIN runs r ON w.latest_run_id = r.run_id
LEFT JOIN repo_connections rc ON w.workspace_id = rc.workspace_id
JOIN teams t USING (team_id)
JOIN team_memberships tm USING (team_id)
JOIN users u ON tm.username = u.username
WHERE w.organization_name  = $1
AND   u.username           = $2
ORDER BY w.updated_at DESC
LIMIT $3
OFFSET $4
;`

type FindWorkspacesByUsernameParams struct {
	OrganizationName pgtype.Text `json:"organization_name"`
	Username         pgtype.Text `json:"username"`
	Limit            pgtype.Int8 `json:"limit"`
	Offset           pgtype.Int8 `json:"offset"`
}

type FindWorkspacesByUsernameRow struct {
	WorkspaceID                pgtype.Text        `json:"workspace_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AllowDestroyPlan           pgtype.Bool        `json:"allow_destroy_plan"`
	AutoApply                  pgtype.Bool        `json:"auto_apply"`
	CanQueueDestroyPlan        pgtype.Bool        `json:"can_queue_destroy_plan"`
	Description                pgtype.Text        `json:"description"`
	Environment                pgtype.Text        `json:"environment"`
	ExecutionMode              pgtype.Text        `json:"execution_mode"`
	GlobalRemoteState          pgtype.Bool        `json:"global_remote_state"`
	MigrationEnvironment       pgtype.Text        `json:"migration_environment"`
	Name                       pgtype.Text        `json:"name"`
	QueueAllRuns               pgtype.Bool        `json:"queue_all_runs"`
	SpeculativeEnabled         pgtype.Bool        `json:"speculative_enabled"`
	SourceName                 pgtype.Text        `json:"source_name"`
	SourceURL                  pgtype.Text        `json:"source_url"`
	StructuredRunOutputEnabled pgtype.Bool        `json:"structured_run_output_enabled"`
	TerraformVersion           pgtype.Text        `json:"terraform_version"`
	TriggerPrefixes            []string           `json:"trigger_prefixes"`
	WorkingDirectory           pgtype.Text        `json:"working_directory"`
	LockRunID                  pgtype.Text        `json:"lock_run_id"`
	LatestRunID                pgtype.Text        `json:"latest_run_id"`
	OrganizationName           pgtype.Text        `json:"organization_name"`
	Branch                     pgtype.Text        `json:"branch"`
	LockUsername               pgtype.Text        `json:"lock_username"`
	CurrentStateVersionID      pgtype.Text        `json:"current_state_version_id"`
	TriggerPatterns            []string           `json:"trigger_patterns"`
	VCSTagsRegex               pgtype.Text        `json:"vcs_tags_regex"`
	AllowCLIApply              pgtype.Bool        `json:"allow_cli_apply"`
	AgentPoolID                pgtype.Text        `json:"agent_pool_id"`
	Tags                       []string           `json:"tags"`
	LatestRunStatus            pgtype.Text        `json:"latest_run_status"`
	UserLock                   *Users             `json:"user_lock"`
	RunLock                    *Runs              `json:"run_lock"`
	WorkspaceConnection        *RepoConnections   `json:"workspace_connection"`
}

// FindWorkspacesByUsername implements Querier.FindWorkspacesByUsername.
func (q *DBQuerier) FindWorkspacesByUsername(ctx context.Context, params FindWorkspacesByUsernameParams) ([]FindWorkspacesByUsernameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspacesByUsername")
	rows, err := q.conn.Query(ctx, findWorkspacesByUsernameSQL, params.OrganizationName, params.Username, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspacesByUsername: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (FindWorkspacesByUsernameRow, error) {
		var item FindWorkspacesByUsernameRow
		if err := row.Scan(&item.WorkspaceID, // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt,                  // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.UpdatedAt,                  // 'updated_at', 'UpdatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.AllowDestroyPlan,           // 'allow_destroy_plan', 'AllowDestroyPlan', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AutoApply,                  // 'auto_apply', 'AutoApply', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.CanQueueDestroyPlan,        // 'can_queue_destroy_plan', 'CanQueueDestroyPlan', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.Description,                // 'description', 'Description', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Environment,                // 'environment', 'Environment', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.ExecutionMode,              // 'execution_mode', 'ExecutionMode', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.GlobalRemoteState,          // 'global_remote_state', 'GlobalRemoteState', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.MigrationEnvironment,       // 'migration_environment', 'MigrationEnvironment', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,                       // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.QueueAllRuns,               // 'queue_all_runs', 'QueueAllRuns', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.SpeculativeEnabled,         // 'speculative_enabled', 'SpeculativeEnabled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.SourceName,                 // 'source_name', 'SourceName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.SourceURL,                  // 'source_url', 'SourceURL', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.StructuredRunOutputEnabled, // 'structured_run_output_enabled', 'StructuredRunOutputEnabled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.TerraformVersion,           // 'terraform_version', 'TerraformVersion', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.TriggerPrefixes,            // 'trigger_prefixes', 'TriggerPrefixes', '[]string', '', '[]string'
			&item.WorkingDirectory,           // 'working_directory', 'WorkingDirectory', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LockRunID,                  // 'lock_run_id', 'LockRunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LatestRunID,                // 'latest_run_id', 'LatestRunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName,           // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Branch,                     // 'branch', 'Branch', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LockUsername,               // 'lock_username', 'LockUsername', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CurrentStateVersionID,      // 'current_state_version_id', 'CurrentStateVersionID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.TriggerPatterns,            // 'trigger_patterns', 'TriggerPatterns', '[]string', '', '[]string'
			&item.VCSTagsRegex,               // 'vcs_tags_regex', 'VCSTagsRegex', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AllowCLIApply,              // 'allow_cli_apply', 'AllowCLIApply', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AgentPoolID,                // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Tags,                       // 'tags', 'Tags', '[]string', '', '[]string'
			&item.LatestRunStatus,            // 'latest_run_status', 'LatestRunStatus', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.UserLock,                   // 'user_lock', 'UserLock', '*Users', '', '*Users'
			&item.RunLock,                    // 'run_lock', 'RunLock', '*Runs', '', '*Runs'
			&item.WorkspaceConnection,        // 'workspace_connection', 'WorkspaceConnection', '*RepoConnections', '', '*RepoConnections'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const countWorkspacesByUsernameSQL = `SELECT count(*)
FROM workspaces w
JOIN workspace_permissions p USING (workspace_id)
JOIN teams t USING (team_id)
JOIN team_memberships tm USING (team_id)
JOIN users u USING (username)
WHERE w.organization_name = $1
AND   u.username          = $2
;`

// CountWorkspacesByUsername implements Querier.CountWorkspacesByUsername.
func (q *DBQuerier) CountWorkspacesByUsername(ctx context.Context, organizationName pgtype.Text, username pgtype.Text) (pgtype.Int8, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CountWorkspacesByUsername")
	rows, err := q.conn.Query(ctx, countWorkspacesByUsernameSQL, organizationName, username)
	if err != nil {
		return pgtype.Int8{}, fmt.Errorf("query CountWorkspacesByUsername: %w", err)
	}

	return pgx.CollectOneRow(rows, func(row pgx.CollectableRow) (pgtype.Int8, error) {
		var item pgtype.Int8
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findWorkspaceByNameSQL = `SELECT w.*,
    (
        SELECT array_agg(name)
        FROM tags
        JOIN workspace_tags wt USING (tag_id)
        WHERE wt.workspace_id = w.workspace_id
    ) AS tags,
    r.status AS latest_run_status,
    (ul.*)::"users" AS user_lock,
    (rl.*)::"runs" AS run_lock,
    (rc.*)::"repo_connections" AS workspace_connection
FROM workspaces w
LEFT JOIN users ul ON w.lock_username = ul.username
LEFT JOIN runs rl ON w.lock_run_id = rl.run_id
LEFT JOIN runs r ON w.latest_run_id = r.run_id
LEFT JOIN repo_connections rc ON w.workspace_id = rc.workspace_id
WHERE w.name              = $1
AND   w.organization_name = $2
;`

type FindWorkspaceByNameRow struct {
	WorkspaceID                pgtype.Text        `json:"workspace_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AllowDestroyPlan           pgtype.Bool        `json:"allow_destroy_plan"`
	AutoApply                  pgtype.Bool        `json:"auto_apply"`
	CanQueueDestroyPlan        pgtype.Bool        `json:"can_queue_destroy_plan"`
	Description                pgtype.Text        `json:"description"`
	Environment                pgtype.Text        `json:"environment"`
	ExecutionMode              pgtype.Text        `json:"execution_mode"`
	GlobalRemoteState          pgtype.Bool        `json:"global_remote_state"`
	MigrationEnvironment       pgtype.Text        `json:"migration_environment"`
	Name                       pgtype.Text        `json:"name"`
	QueueAllRuns               pgtype.Bool        `json:"queue_all_runs"`
	SpeculativeEnabled         pgtype.Bool        `json:"speculative_enabled"`
	SourceName                 pgtype.Text        `json:"source_name"`
	SourceURL                  pgtype.Text        `json:"source_url"`
	StructuredRunOutputEnabled pgtype.Bool        `json:"structured_run_output_enabled"`
	TerraformVersion           pgtype.Text        `json:"terraform_version"`
	TriggerPrefixes            []string           `json:"trigger_prefixes"`
	WorkingDirectory           pgtype.Text        `json:"working_directory"`
	LockRunID                  pgtype.Text        `json:"lock_run_id"`
	LatestRunID                pgtype.Text        `json:"latest_run_id"`
	OrganizationName           pgtype.Text        `json:"organization_name"`
	Branch                     pgtype.Text        `json:"branch"`
	LockUsername               pgtype.Text        `json:"lock_username"`
	CurrentStateVersionID      pgtype.Text        `json:"current_state_version_id"`
	TriggerPatterns            []string           `json:"trigger_patterns"`
	VCSTagsRegex               pgtype.Text        `json:"vcs_tags_regex"`
	AllowCLIApply              pgtype.Bool        `json:"allow_cli_apply"`
	AgentPoolID                pgtype.Text        `json:"agent_pool_id"`
	Tags                       []string           `json:"tags"`
	LatestRunStatus            pgtype.Text        `json:"latest_run_status"`
	UserLock                   *Users             `json:"user_lock"`
	RunLock                    *Runs              `json:"run_lock"`
	WorkspaceConnection        *RepoConnections   `json:"workspace_connection"`
}

// FindWorkspaceByName implements Querier.FindWorkspaceByName.
func (q *DBQuerier) FindWorkspaceByName(ctx context.Context, name pgtype.Text, organizationName pgtype.Text) (FindWorkspaceByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceByName")
	rows, err := q.conn.Query(ctx, findWorkspaceByNameSQL, name, organizationName)
	if err != nil {
		return FindWorkspaceByNameRow{}, fmt.Errorf("query FindWorkspaceByName: %w", err)
	}

	return pgx.CollectOneRow(rows, func(row pgx.CollectableRow) (FindWorkspaceByNameRow, error) {
		var item FindWorkspaceByNameRow
		if err := row.Scan(&item.WorkspaceID, // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt,                  // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.UpdatedAt,                  // 'updated_at', 'UpdatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.AllowDestroyPlan,           // 'allow_destroy_plan', 'AllowDestroyPlan', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AutoApply,                  // 'auto_apply', 'AutoApply', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.CanQueueDestroyPlan,        // 'can_queue_destroy_plan', 'CanQueueDestroyPlan', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.Description,                // 'description', 'Description', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Environment,                // 'environment', 'Environment', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.ExecutionMode,              // 'execution_mode', 'ExecutionMode', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.GlobalRemoteState,          // 'global_remote_state', 'GlobalRemoteState', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.MigrationEnvironment,       // 'migration_environment', 'MigrationEnvironment', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,                       // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.QueueAllRuns,               // 'queue_all_runs', 'QueueAllRuns', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.SpeculativeEnabled,         // 'speculative_enabled', 'SpeculativeEnabled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.SourceName,                 // 'source_name', 'SourceName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.SourceURL,                  // 'source_url', 'SourceURL', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.StructuredRunOutputEnabled, // 'structured_run_output_enabled', 'StructuredRunOutputEnabled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.TerraformVersion,           // 'terraform_version', 'TerraformVersion', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.TriggerPrefixes,            // 'trigger_prefixes', 'TriggerPrefixes', '[]string', '', '[]string'
			&item.WorkingDirectory,           // 'working_directory', 'WorkingDirectory', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LockRunID,                  // 'lock_run_id', 'LockRunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LatestRunID,                // 'latest_run_id', 'LatestRunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName,           // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Branch,                     // 'branch', 'Branch', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LockUsername,               // 'lock_username', 'LockUsername', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CurrentStateVersionID,      // 'current_state_version_id', 'CurrentStateVersionID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.TriggerPatterns,            // 'trigger_patterns', 'TriggerPatterns', '[]string', '', '[]string'
			&item.VCSTagsRegex,               // 'vcs_tags_regex', 'VCSTagsRegex', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AllowCLIApply,              // 'allow_cli_apply', 'AllowCLIApply', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AgentPoolID,                // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Tags,                       // 'tags', 'Tags', '[]string', '', '[]string'
			&item.LatestRunStatus,            // 'latest_run_status', 'LatestRunStatus', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.UserLock,                   // 'user_lock', 'UserLock', '*Users', '', '*Users'
			&item.RunLock,                    // 'run_lock', 'RunLock', '*Runs', '', '*Runs'
			&item.WorkspaceConnection,        // 'workspace_connection', 'WorkspaceConnection', '*RepoConnections', '', '*RepoConnections'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findWorkspaceByIDSQL = `SELECT w.*,
    (
        SELECT array_agg(name)
        FROM tags
        JOIN workspace_tags wt USING (tag_id)
        WHERE wt.workspace_id = w.workspace_id
    ) AS tags,
    r.status AS latest_run_status,
    (ul.*)::"users" AS user_lock,
    (rl.*)::"runs" AS run_lock,
    (rc.*)::"repo_connections" AS workspace_connection
FROM workspaces w
LEFT JOIN users ul ON w.lock_username = ul.username
LEFT JOIN runs rl ON w.lock_run_id = rl.run_id
LEFT JOIN runs r ON w.latest_run_id = r.run_id
LEFT JOIN repo_connections rc ON w.workspace_id = rc.workspace_id
WHERE w.workspace_id = $1
;`

type FindWorkspaceByIDRow struct {
	WorkspaceID                pgtype.Text        `json:"workspace_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AllowDestroyPlan           pgtype.Bool        `json:"allow_destroy_plan"`
	AutoApply                  pgtype.Bool        `json:"auto_apply"`
	CanQueueDestroyPlan        pgtype.Bool        `json:"can_queue_destroy_plan"`
	Description                pgtype.Text        `json:"description"`
	Environment                pgtype.Text        `json:"environment"`
	ExecutionMode              pgtype.Text        `json:"execution_mode"`
	GlobalRemoteState          pgtype.Bool        `json:"global_remote_state"`
	MigrationEnvironment       pgtype.Text        `json:"migration_environment"`
	Name                       pgtype.Text        `json:"name"`
	QueueAllRuns               pgtype.Bool        `json:"queue_all_runs"`
	SpeculativeEnabled         pgtype.Bool        `json:"speculative_enabled"`
	SourceName                 pgtype.Text        `json:"source_name"`
	SourceURL                  pgtype.Text        `json:"source_url"`
	StructuredRunOutputEnabled pgtype.Bool        `json:"structured_run_output_enabled"`
	TerraformVersion           pgtype.Text        `json:"terraform_version"`
	TriggerPrefixes            []string           `json:"trigger_prefixes"`
	WorkingDirectory           pgtype.Text        `json:"working_directory"`
	LockRunID                  pgtype.Text        `json:"lock_run_id"`
	LatestRunID                pgtype.Text        `json:"latest_run_id"`
	OrganizationName           pgtype.Text        `json:"organization_name"`
	Branch                     pgtype.Text        `json:"branch"`
	LockUsername               pgtype.Text        `json:"lock_username"`
	CurrentStateVersionID      pgtype.Text        `json:"current_state_version_id"`
	TriggerPatterns            []string           `json:"trigger_patterns"`
	VCSTagsRegex               pgtype.Text        `json:"vcs_tags_regex"`
	AllowCLIApply              pgtype.Bool        `json:"allow_cli_apply"`
	AgentPoolID                pgtype.Text        `json:"agent_pool_id"`
	Tags                       []string           `json:"tags"`
	LatestRunStatus            pgtype.Text        `json:"latest_run_status"`
	UserLock                   *Users             `json:"user_lock"`
	RunLock                    *Runs              `json:"run_lock"`
	WorkspaceConnection        *RepoConnections   `json:"workspace_connection"`
}

// FindWorkspaceByID implements Querier.FindWorkspaceByID.
func (q *DBQuerier) FindWorkspaceByID(ctx context.Context, id pgtype.Text) (FindWorkspaceByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceByID")
	rows, err := q.conn.Query(ctx, findWorkspaceByIDSQL, id)
	if err != nil {
		return FindWorkspaceByIDRow{}, fmt.Errorf("query FindWorkspaceByID: %w", err)
	}

	return pgx.CollectOneRow(rows, func(row pgx.CollectableRow) (FindWorkspaceByIDRow, error) {
		var item FindWorkspaceByIDRow
		if err := row.Scan(&item.WorkspaceID, // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt,                  // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.UpdatedAt,                  // 'updated_at', 'UpdatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.AllowDestroyPlan,           // 'allow_destroy_plan', 'AllowDestroyPlan', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AutoApply,                  // 'auto_apply', 'AutoApply', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.CanQueueDestroyPlan,        // 'can_queue_destroy_plan', 'CanQueueDestroyPlan', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.Description,                // 'description', 'Description', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Environment,                // 'environment', 'Environment', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.ExecutionMode,              // 'execution_mode', 'ExecutionMode', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.GlobalRemoteState,          // 'global_remote_state', 'GlobalRemoteState', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.MigrationEnvironment,       // 'migration_environment', 'MigrationEnvironment', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,                       // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.QueueAllRuns,               // 'queue_all_runs', 'QueueAllRuns', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.SpeculativeEnabled,         // 'speculative_enabled', 'SpeculativeEnabled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.SourceName,                 // 'source_name', 'SourceName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.SourceURL,                  // 'source_url', 'SourceURL', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.StructuredRunOutputEnabled, // 'structured_run_output_enabled', 'StructuredRunOutputEnabled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.TerraformVersion,           // 'terraform_version', 'TerraformVersion', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.TriggerPrefixes,            // 'trigger_prefixes', 'TriggerPrefixes', '[]string', '', '[]string'
			&item.WorkingDirectory,           // 'working_directory', 'WorkingDirectory', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LockRunID,                  // 'lock_run_id', 'LockRunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LatestRunID,                // 'latest_run_id', 'LatestRunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName,           // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Branch,                     // 'branch', 'Branch', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LockUsername,               // 'lock_username', 'LockUsername', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CurrentStateVersionID,      // 'current_state_version_id', 'CurrentStateVersionID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.TriggerPatterns,            // 'trigger_patterns', 'TriggerPatterns', '[]string', '', '[]string'
			&item.VCSTagsRegex,               // 'vcs_tags_regex', 'VCSTagsRegex', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AllowCLIApply,              // 'allow_cli_apply', 'AllowCLIApply', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AgentPoolID,                // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Tags,                       // 'tags', 'Tags', '[]string', '', '[]string'
			&item.LatestRunStatus,            // 'latest_run_status', 'LatestRunStatus', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.UserLock,                   // 'user_lock', 'UserLock', '*Users', '', '*Users'
			&item.RunLock,                    // 'run_lock', 'RunLock', '*Runs', '', '*Runs'
			&item.WorkspaceConnection,        // 'workspace_connection', 'WorkspaceConnection', '*RepoConnections', '', '*RepoConnections'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const findWorkspaceByIDForUpdateSQL = `SELECT w.*,
    (
        SELECT array_agg(name)
        FROM tags
        JOIN workspace_tags wt USING (tag_id)
        WHERE wt.workspace_id = w.workspace_id
    ) AS tags,
    r.status AS latest_run_status,
    (ul.*)::"users" AS user_lock,
    (rl.*)::"runs" AS run_lock,
    (rc.*)::"repo_connections" AS workspace_connection
FROM workspaces w
LEFT JOIN users ul ON w.lock_username = ul.username
LEFT JOIN runs rl ON w.lock_run_id = rl.run_id
LEFT JOIN runs r ON w.latest_run_id = r.run_id
LEFT JOIN repo_connections rc ON w.workspace_id = rc.workspace_id
WHERE w.workspace_id = $1
FOR UPDATE OF w;`

type FindWorkspaceByIDForUpdateRow struct {
	WorkspaceID                pgtype.Text        `json:"workspace_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AllowDestroyPlan           pgtype.Bool        `json:"allow_destroy_plan"`
	AutoApply                  pgtype.Bool        `json:"auto_apply"`
	CanQueueDestroyPlan        pgtype.Bool        `json:"can_queue_destroy_plan"`
	Description                pgtype.Text        `json:"description"`
	Environment                pgtype.Text        `json:"environment"`
	ExecutionMode              pgtype.Text        `json:"execution_mode"`
	GlobalRemoteState          pgtype.Bool        `json:"global_remote_state"`
	MigrationEnvironment       pgtype.Text        `json:"migration_environment"`
	Name                       pgtype.Text        `json:"name"`
	QueueAllRuns               pgtype.Bool        `json:"queue_all_runs"`
	SpeculativeEnabled         pgtype.Bool        `json:"speculative_enabled"`
	SourceName                 pgtype.Text        `json:"source_name"`
	SourceURL                  pgtype.Text        `json:"source_url"`
	StructuredRunOutputEnabled pgtype.Bool        `json:"structured_run_output_enabled"`
	TerraformVersion           pgtype.Text        `json:"terraform_version"`
	TriggerPrefixes            []string           `json:"trigger_prefixes"`
	WorkingDirectory           pgtype.Text        `json:"working_directory"`
	LockRunID                  pgtype.Text        `json:"lock_run_id"`
	LatestRunID                pgtype.Text        `json:"latest_run_id"`
	OrganizationName           pgtype.Text        `json:"organization_name"`
	Branch                     pgtype.Text        `json:"branch"`
	LockUsername               pgtype.Text        `json:"lock_username"`
	CurrentStateVersionID      pgtype.Text        `json:"current_state_version_id"`
	TriggerPatterns            []string           `json:"trigger_patterns"`
	VCSTagsRegex               pgtype.Text        `json:"vcs_tags_regex"`
	AllowCLIApply              pgtype.Bool        `json:"allow_cli_apply"`
	AgentPoolID                pgtype.Text        `json:"agent_pool_id"`
	Tags                       []string           `json:"tags"`
	LatestRunStatus            pgtype.Text        `json:"latest_run_status"`
	UserLock                   *Users             `json:"user_lock"`
	RunLock                    *Runs              `json:"run_lock"`
	WorkspaceConnection        *RepoConnections   `json:"workspace_connection"`
}

// FindWorkspaceByIDForUpdate implements Querier.FindWorkspaceByIDForUpdate.
func (q *DBQuerier) FindWorkspaceByIDForUpdate(ctx context.Context, id pgtype.Text) (FindWorkspaceByIDForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceByIDForUpdate")
	rows, err := q.conn.Query(ctx, findWorkspaceByIDForUpdateSQL, id)
	if err != nil {
		return FindWorkspaceByIDForUpdateRow{}, fmt.Errorf("query FindWorkspaceByIDForUpdate: %w", err)
	}

	return pgx.CollectOneRow(rows, func(row pgx.CollectableRow) (FindWorkspaceByIDForUpdateRow, error) {
		var item FindWorkspaceByIDForUpdateRow
		if err := row.Scan(&item.WorkspaceID, // 'workspace_id', 'WorkspaceID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CreatedAt,                  // 'created_at', 'CreatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.UpdatedAt,                  // 'updated_at', 'UpdatedAt', 'pgtype.Timestamptz', 'github.com/jackc/pgx/v5/pgtype', 'Timestamptz'
			&item.AllowDestroyPlan,           // 'allow_destroy_plan', 'AllowDestroyPlan', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AutoApply,                  // 'auto_apply', 'AutoApply', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.CanQueueDestroyPlan,        // 'can_queue_destroy_plan', 'CanQueueDestroyPlan', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.Description,                // 'description', 'Description', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Environment,                // 'environment', 'Environment', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.ExecutionMode,              // 'execution_mode', 'ExecutionMode', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.GlobalRemoteState,          // 'global_remote_state', 'GlobalRemoteState', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.MigrationEnvironment,       // 'migration_environment', 'MigrationEnvironment', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Name,                       // 'name', 'Name', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.QueueAllRuns,               // 'queue_all_runs', 'QueueAllRuns', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.SpeculativeEnabled,         // 'speculative_enabled', 'SpeculativeEnabled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.SourceName,                 // 'source_name', 'SourceName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.SourceURL,                  // 'source_url', 'SourceURL', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.StructuredRunOutputEnabled, // 'structured_run_output_enabled', 'StructuredRunOutputEnabled', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.TerraformVersion,           // 'terraform_version', 'TerraformVersion', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.TriggerPrefixes,            // 'trigger_prefixes', 'TriggerPrefixes', '[]string', '', '[]string'
			&item.WorkingDirectory,           // 'working_directory', 'WorkingDirectory', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LockRunID,                  // 'lock_run_id', 'LockRunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LatestRunID,                // 'latest_run_id', 'LatestRunID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.OrganizationName,           // 'organization_name', 'OrganizationName', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Branch,                     // 'branch', 'Branch', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.LockUsername,               // 'lock_username', 'LockUsername', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.CurrentStateVersionID,      // 'current_state_version_id', 'CurrentStateVersionID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.TriggerPatterns,            // 'trigger_patterns', 'TriggerPatterns', '[]string', '', '[]string'
			&item.VCSTagsRegex,               // 'vcs_tags_regex', 'VCSTagsRegex', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.AllowCLIApply,              // 'allow_cli_apply', 'AllowCLIApply', 'pgtype.Bool', 'github.com/jackc/pgx/v5/pgtype', 'Bool'
			&item.AgentPoolID,                // 'agent_pool_id', 'AgentPoolID', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.Tags,                       // 'tags', 'Tags', '[]string', '', '[]string'
			&item.LatestRunStatus,            // 'latest_run_status', 'LatestRunStatus', 'pgtype.Text', 'github.com/jackc/pgx/v5/pgtype', 'Text'
			&item.UserLock,                   // 'user_lock', 'UserLock', '*Users', '', '*Users'
			&item.RunLock,                    // 'run_lock', 'RunLock', '*Runs', '', '*Runs'
			&item.WorkspaceConnection,        // 'workspace_connection', 'WorkspaceConnection', '*RepoConnections', '', '*RepoConnections'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const updateWorkspaceByIDSQL = `UPDATE workspaces
SET
    agent_pool_id                 = $1,
    allow_destroy_plan            = $2,
    allow_cli_apply               = $3,
    auto_apply                    = $4,
    branch                        = $5,
    description                   = $6,
    execution_mode                = $7,
    global_remote_state           = $8,
    name                          = $9,
    queue_all_runs                = $10,
    speculative_enabled           = $11,
    structured_run_output_enabled = $12,
    terraform_version             = $13,
    trigger_prefixes              = $14,
    trigger_patterns              = $15,
    vcs_tags_regex                = $16,
    working_directory             = $17,
    updated_at                    = $18
WHERE workspace_id = $19
RETURNING workspace_id;`

type UpdateWorkspaceByIDParams struct {
	AgentPoolID                pgtype.Text        `json:"agent_pool_id"`
	AllowDestroyPlan           pgtype.Bool        `json:"allow_destroy_plan"`
	AllowCLIApply              pgtype.Bool        `json:"allow_cli_apply"`
	AutoApply                  pgtype.Bool        `json:"auto_apply"`
	Branch                     pgtype.Text        `json:"branch"`
	Description                pgtype.Text        `json:"description"`
	ExecutionMode              pgtype.Text        `json:"execution_mode"`
	GlobalRemoteState          pgtype.Bool        `json:"global_remote_state"`
	Name                       pgtype.Text        `json:"name"`
	QueueAllRuns               pgtype.Bool        `json:"queue_all_runs"`
	SpeculativeEnabled         pgtype.Bool        `json:"speculative_enabled"`
	StructuredRunOutputEnabled pgtype.Bool        `json:"structured_run_output_enabled"`
	TerraformVersion           pgtype.Text        `json:"terraform_version"`
	TriggerPrefixes            []string           `json:"trigger_prefixes"`
	TriggerPatterns            []string           `json:"trigger_patterns"`
	VCSTagsRegex               pgtype.Text        `json:"vcs_tags_regex"`
	WorkingDirectory           pgtype.Text        `json:"working_directory"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	ID                         pgtype.Text        `json:"id"`
}

// UpdateWorkspaceByID implements Querier.UpdateWorkspaceByID.
func (q *DBQuerier) UpdateWorkspaceByID(ctx context.Context, params UpdateWorkspaceByIDParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateWorkspaceByID")
	rows, err := q.conn.Query(ctx, updateWorkspaceByIDSQL, params.AgentPoolID, params.AllowDestroyPlan, params.AllowCLIApply, params.AutoApply, params.Branch, params.Description, params.ExecutionMode, params.GlobalRemoteState, params.Name, params.QueueAllRuns, params.SpeculativeEnabled, params.StructuredRunOutputEnabled, params.TerraformVersion, params.TriggerPrefixes, params.TriggerPatterns, params.VCSTagsRegex, params.WorkingDirectory, params.UpdatedAt, params.ID)
	if err != nil {
		return pgtype.Text{}, fmt.Errorf("query UpdateWorkspaceByID: %w", err)
	}

	return pgx.CollectOneRow(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const updateWorkspaceLockByIDSQL = `UPDATE workspaces
SET
    lock_username = $1,
    lock_run_id = $2
WHERE workspace_id = $3;`

type UpdateWorkspaceLockByIDParams struct {
	Username    pgtype.Text `json:"username"`
	RunID       pgtype.Text `json:"run_id"`
	WorkspaceID pgtype.Text `json:"workspace_id"`
}

// UpdateWorkspaceLockByID implements Querier.UpdateWorkspaceLockByID.
func (q *DBQuerier) UpdateWorkspaceLockByID(ctx context.Context, params UpdateWorkspaceLockByIDParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateWorkspaceLockByID")
	cmdTag, err := q.conn.Exec(ctx, updateWorkspaceLockByIDSQL, params.Username, params.RunID, params.WorkspaceID)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query UpdateWorkspaceLockByID: %w", err)
	}
	return cmdTag, err
}

const updateWorkspaceLatestRunSQL = `UPDATE workspaces
SET latest_run_id = $1
WHERE workspace_id = $2;`

// UpdateWorkspaceLatestRun implements Querier.UpdateWorkspaceLatestRun.
func (q *DBQuerier) UpdateWorkspaceLatestRun(ctx context.Context, runID pgtype.Text, workspaceID pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateWorkspaceLatestRun")
	cmdTag, err := q.conn.Exec(ctx, updateWorkspaceLatestRunSQL, runID, workspaceID)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query UpdateWorkspaceLatestRun: %w", err)
	}
	return cmdTag, err
}

const updateWorkspaceCurrentStateVersionIDSQL = `UPDATE workspaces
SET current_state_version_id = $1
WHERE workspace_id = $2
RETURNING workspace_id;`

// UpdateWorkspaceCurrentStateVersionID implements Querier.UpdateWorkspaceCurrentStateVersionID.
func (q *DBQuerier) UpdateWorkspaceCurrentStateVersionID(ctx context.Context, stateVersionID pgtype.Text, workspaceID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateWorkspaceCurrentStateVersionID")
	rows, err := q.conn.Query(ctx, updateWorkspaceCurrentStateVersionIDSQL, stateVersionID, workspaceID)
	if err != nil {
		return pgtype.Text{}, fmt.Errorf("query UpdateWorkspaceCurrentStateVersionID: %w", err)
	}

	return pgx.CollectOneRow(rows, func(row pgx.CollectableRow) (pgtype.Text, error) {
		var item pgtype.Text
		if err := row.Scan(&item); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const deleteWorkspaceByIDSQL = `DELETE
FROM workspaces
WHERE workspace_id = $1;`

// DeleteWorkspaceByID implements Querier.DeleteWorkspaceByID.
func (q *DBQuerier) DeleteWorkspaceByID(ctx context.Context, workspaceID pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWorkspaceByID")
	cmdTag, err := q.conn.Exec(ctx, deleteWorkspaceByIDSQL, workspaceID)
	if err != nil {
		return pgconn.CommandTag{}, fmt.Errorf("exec query DeleteWorkspaceByID: %w", err)
	}
	return cmdTag, err
}
